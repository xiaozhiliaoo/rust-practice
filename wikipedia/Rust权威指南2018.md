标准Rust风格使用4个空格而不是Tab来实现缩进。

预导入 （prelude）模块

字符串：String::new() 关联函数

String是标准库中的一个字符串类型，它在内部使用了UTF-8格式的编码并可以按照需求扩展自己的大小。

引用&：引用在不同的地方访问同一份数据，而无须付出多余的拷贝开销

引用与变量一样，默认情况下也是不可变的。

使用Result类型来处理可能失败的情况

Result而言，它拥有Ok和Err两个变体。

binary crate，library crate

Cargo.lock 文件确保我们的构建是可重现的

std::result Result

std::cmp Ordering 

loop关键字会创建一个无限循环

字符串转其他类型：parse()

在使用某些重型数据结构时，适当地使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效率；
而当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解。

变量隐藏（shadow） let

Rust是一门静态类型语言，它在编译程序的过程中需要知道所有变量的具体类型。

Rust对于整数字面量的默认推导类型i32通常就是一个很好的选择：它在大部分情形下都是运算速度最快的那一个

Rust中，默认会将浮点数字面量的类型推导为f64

字符类型 char

Rust提供了两种内置的基础复合类型：元组 （tuple）和数组（array）。

你还不确定什么时候应该使用数组和动态数组，那就先使用动态数组vec。

想在栈上而不是堆上为数据分配空间时，或者想要确保总有固定数量的元素时，数组是一个非常有用的工具

Rust不关心你在何处定义函数，只要这些定义对于使用区域是可见的即可。

在函数签名中，你必须 显式地声明每个参数的类型。这是在Rust
设计中设计者们经过慎重考虑后做出的决定：由于类型被显式地注明
了，因此编译器不需要通过其他部分的代码进行推导就能明确地知道
你的意图。

语句指那些执行操作但不返回值的指令，而表达式则是指会进行计算并产生一个值作为结果的指令。

Rust中编写的大部分代码都会是表达式：调用函数是表达式，调用宏是表达式，
我们用来创建新作用域的花括号（{}）同样也是表达式。

分支 arm

过多的else if表达式可能会使代码变得杂乱无章。分支结构语法match可以被用
来应对这种情况。

let if

Rust提供了3种循环：loop、while和for

使用for来循环遍历集合，大部分的Rus开发者也会选择使用for循环

所有权：Rust才能够在没有垃圾回收机制的前提下保障内存安全。

包含特定规则的所有权系统来管理内存，这套规则允许编译器在编译过程中
执行检查工作，而不会产生任何的运行时开销。

所有存储在栈中的数据都必须拥有一个已知且固定的大小。
对于那些在编译期无法确定大小的数据，你就只能将它们存储在堆中。

当你希望将数据放入堆中时，你就可以请求特定大小的空间。操作系统会根据你的请求在堆中找到
一块足够大的可用空间，将它标记为已使用，并把指向这片空间地址的指针 返回给我们。

所有权规则：
Rust中的每一个值都有一个对应的变量作为它的所有者
在同一时间内，值有且仅有一个所有者。
当所有者离开自己的作用域时，它持有的值就会被释放掉

字符串字面量 

字符串类型String：这个类型会在堆上分配到自己需要的存储空间，所以它能够处理在编译时未知大小的文本

String::new，String::from s.push_str

清理内存：1 手动 2 垃圾回收 3 rust：内存会自动地在拥有它的变量离开作用域后进行释放

Rust在变量离开作用域时，会调用一个叫作drop的特殊函数：drop 函数的核心是Drop trait。任何实现了 Drop trait 的类型都可以自定义析构逻辑

通过 drop 和 Drop trait，Rust 提供了强大且安全的内存管理机制。

变量和数据交互的方式：移动

let s1 = String::from("hello");
let s2 = s1;
s1被move了。

Rust使第一个变量无效了，所以我们使用了新的术语移动 （move）来描述这一行为，而不再使用浅度拷贝。

设计原则：Rust永远不会自动地创建数据的深度拷贝。

变量和数据交互的方式：克隆（深拷贝）

Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型

一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性。
对于String，变量就可以在赋值给其他变量之后所有权转移。

Copy这种trait的类型：
• 所有的整数类型，诸如u32。
• 仅拥有两种值（true和false）的布尔类型：bool。
• 字符类型：char。
• 所有的浮点类型，诸如f64。

String实现了 Drop trait，但没有实现 Copy trait。但它实现了 Clone trait。

复制数据的trait：Clone（std::clone）和Copy（std::marker）

Copy和Clone区别？

如果一种类型本身或这种类型的任意成员实现了Drop这
种trait，那么Rust就不允许其实现Copy这种trait。尝试给某个需要在离
开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错
误。

一个类型不能同时实现 Copy 和 Drop trait。这是因为 Copy 和 Drop 在语义上是互斥的。

任何简单标量的组合类型都可以是Copy的，任何需要分配内存或某种资源的类型都不会是Copy的。

将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样

所有权的转移-也叫move移动：变量赋值，值传递函数，函数返回值

在所有的函数中都要获取所有权并返回所有权显得有些烦琐。假如你希望在调用函数时保留参数的所有权，那么就不得不将传入的值作为结果返回。除了这些需要保留所有权的值，函数还可能会返回它们本身的结果。

当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返
回值，毕竟在这种情况下，我们根本没有取得所有权。

通过引用传递参数给函数的方法也被称为借用 （borrowing）

可变引用在使用上有一个很大的限制：对于特定作用域中的特定数据来说，一次只能声明一个可变引用。这个规则使得引用的可变性只能以一种受到严格限制的方式来使用。许多刚刚接触Rust的开发者会反复地与它进行斗争，因为大部分的语言都允许你随意修改变量。

不能 在拥有不可变引用的同时创建可变引用。

Rust语言中，编译器会确保引用永远不会进入这种悬垂状态。

引用规则：
1.在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
2.引用总是有效的。

不持有所有权的数据类型：String和切片

字符串切片是指向String对象中某个连续部分的引用，字符串切片是引用。
&str是一个不可变的引用
字符串切片的类型写作&str

字符串字面量就是切片

fn first_word(s: &String) -> usize
fn first_word(s: &String) -> &str 
fn first_word(s: &str) -> &str

在定义函数时使用字符串切片来代替字符串引用会使我们的API更加通用

当我们拥有了某个变量的不可变引用时，我们就无法同时取得该变量的可变引用

i32切片：&[i32]

使用不需要对字段命名的元组结构体来创建不同的类型

添加注解来派生Debug trait

格式化文本中的{}会告知println! 使用名为Display的格式化方法

Rust没有为结构体提供默认的Display实现。

格式化文本中的:?会告知println! 当前的结构体需要使用名为Debug的格式化输出。

结构体impl块：
方法，接收第一个参数self，调用 .
关联函数，不接受self，调用 ::  关联函数常常被用作构造器来返回一个结构体的新实例

String::from 关联函数

自定义类型：枚举，结构体

枚举的每一个类型叫变体。

枚举的变体中嵌入任意类型的数据，无论是字符串、数值，还是结构体，甚至可以嵌入另外一个枚举

Option枚举

std::option

无论在什么地方，只要一个值的类型不是Option<T>的，我们就可以安全地假设这个值不是非空的。这是Rust为了限制空值泛滥以增加Rust代码安全性而做出
的一个有意为之的设计决策。

为了持有一个可能为空的值，我们总是需要将它显式地放入对应类型的Option<T>值中

使用if let意味着你可以编写更少的代码，使用更少的缩进，使用
更少的模板代码。但是，你也放弃了match所附带的穷尽性检查。究竟
应该使用match还是if let取决于你当时所处的环境，这是一个在代码简
捷性与穷尽性检查之间取舍的过程。

if let视作match的语法糖。它只在值满足某一特定模式时运行代码，而忽略其他所有的可能性。

package,crate,moudle,path

首先，一个包中只能拥有最多一个库单元包。
其次，包可以拥有任意多个二进制单元包。
最后，包内必须存在至少一个单元包（库单元包或二进制单元包）。

通过定义模块来控制作用域及私有性

一旦程序获得了一个有效的引用，借用检查器就会执行所有权规则和借用规则，来保证这个引用及其他任
何指向这个动态数组的引用始终有效。

字符串使用了UTF-8编码。

Rust在语言核心部分只有一种字符串类型，那就是字符串切片str，它通常以借用的形式（&str）出现。

String 所有权版本 
&str 借用者版本

OsString、OsStr、CString及CStr

使用+运算符或format! 宏来拼接字符串（用format！简单些）

所有权两类：拥有，借用(引用)。  变量声明出来就要问这东西有效吗？谁拥有他？

我们只能将&str与String相加，而不能将两个String相加。
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // 注意这里的s1已经被移动且再也不能被使用了

+ 类似于 fn add(self, s: &str) -> String

对于那些实现了Copy trait的类型，例如i32，它们的值会被简单地复制到哈希映射中。而对于String这种持有所有权的值，其值将会转移且所有权会转移给哈希映射

使用生命周期保证引用的有效性

不可恢复错误与panic!
可恢复错误与Result

失败时触发panic的快捷方式：unwrap和expect

传播错误 ？ 
？运算符所接收的错误值会隐式地被from函数处理，这个函数定义于标准库的
From trait中。用于在错误类型之间进行转换。

?运算符只能被用于返回Result的函数

？运算符的函数必须返回Result、Option或任何实现了std::ops::Try的类

Box<dyn Error>被称作trait对象，理解为“任何可能的错误类型”。

fn largest<T>(list: &[T]) -> T 
这段定义可以被理解为：函数largest拥有泛型参数T，它接收一个
名为list的T值切片作为参数，并返回一个同样拥有类型T的值作为结果。

Rust 会在编译时执行泛型代码的单态化（monomorphization）。单态化 是一个在编译期将泛型代码转换为特定代码的过程，它会将所有使用过的具体类型填入泛型参数从而得到
有具体类型的代码。无须为泛型的使用付出任何运行时的代价。

trait：定义共享行为

为类型实现trait：impl trait for 类型

为类型实现方法和关联函数：impl 类型

实现trait有一个限制：只有当trait或类型定义于我们的库中时，我们才能为该类型实现对应的trait。

使用trait作为参数

trait约束: 
pub fn notify<T: Summary + Display>(item: T)
pub fn notify(item: impl Summary + Display)

使用where从句来简化trait约束：

fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32

fn some_function<T, U>(t: T, u: U) -> i32 where T: Display + Clone, U: Clone + Debug

重度依赖于trait的功能：闭包（closure）与迭代器（iterator）

fn largest<T: PartialOrd + Copy>(list: &[T]) -> T

fn largest2<T: PartialOrd>(list: &[T]) -> &T

使用trait约束来有条件地实现方法

生命周期是另一种泛型

使用生命周期保证引用的有效性

生命周期最主要的目标在于避免悬垂引用

借用检查器:比较不同的作用域并确定所有借用的合法性

单个生命周期的标注本身并没有太多意义，标注之所以存在是为了向Rust描述多个泛型生命周期参数之间的关系。

参数与返回值中的所有引用都必须拥有相同的生命周期，泛型生命周期'a会被具体化为x与y两者中生命周期较短的那一个。
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str

指定生命周期的方式往往取决于函数的具体功能。

从根本上说，生命周期语法就是用来关联一个函数中不同参数及返回值的生命周期的。


当函数返回一个引用时，返回类型的生命周期参数必须要与其中一个参数的生命周期参数相匹配。当返回的引用没有 指向任何参数时，那么它只可能是指向了一个创建于函数内部的值，由于这个值会因为函数的结束而离开作用域，所以返回的内容也就变成了悬垂引用。

每个引用都必须有一个显式的生命周期。

任何引用都有一个生命周期，并且需要为使用引用的函数或结构体指定生命周期参数。
fn first_word(s: &str) -> &str 可以忽略生命周期语法

生命周期省略规则：
1.每一个引用参数都会拥有自己的生命周期参数
2.当只存在一个输入生命周期参数时，这个生命周期会被赋予给所有输出生命周期参数
3.当拥有多个输入生命周期参数，而其中一个是&self或&mut self时，self的生命周期会被赋予给所有的输出生命周期参数。

有&self是方法，不是函数。

同时使用泛型参数、trait约束与生命周期：

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
where T: Display

生命周期和范型都放到了<>里面的，trait约束在where后面

使用生命周期来确保这些灵活的代码不会产生任何悬垂引用

单元测试，性能测试，文档测试

使用assert_eq! 宏和assert_ne! 宏判断相等性
使用should_panic检查panic
使用Result<T, E>编写测试

Box<dyn Error>是trait对象。
你只需要知道Box<dyn Error>意味着函数会返回一个实现了Error trait的类型，但我们并不需
要指定具体的类型是什么。这意味着我们可以在不同的错误场景下返回不同的错误类型， 语句中的dyn 关键字所表达的正是这种“动态”（dynamic）的含义。

函数式语言特性：迭代器与闭包

使用闭包是因为想要在一个地方定义要调用的代码，将其存储起来，并在稍后的地方调用它。

使用泛型参数和Fn trait来存储闭包

每一个闭包实例都有它自己的匿名类型。换句话说，即便两个闭包拥有完全相同的签名，它们的类型也被认为是不一样的。

所有的闭包都至少实现了Fn、FnMut及FnOnce中的一个trait

闭包视作一个内部的匿名函数来使用

使用闭包捕获上下文环境

闭包可以通过3种方式从它们的环境中捕获值，这和函数接收参数的3种方式是完全一致的：获取所有权、可变借用及不可变借用
FnOnce：闭包必须在定义时取得这些变量的所有权并将它们移动至闭包中。
FnMut：可以从环境中可变地借用值并对它们进行修改。
Fn：从环境中不可变地借用值。

强制闭包获取环境中值的所有权，那么你可以在参数列表前添加move关键字。
这个特性在把闭包传入新线程时相当有用，它可以将捕获的变量一并移动到新线程中去。

Iterator trait

iter方法生成的是一个不可变引用的迭代器。迭代完之后还可以继续使用。
into_iter取得所有权并返回元素本身的迭代器。遍历完之后值被move了就用不了。
iter_mut可变引用的迭代器。

let v1 = vec![1, 2, 3];
let v1_iter = v1.into_iter();
let total: i32 = v1_iter.sum();
println!("{:?}", v1); // Value used after being moved [E0382]

let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
let total: i32 = v1_iter.sum();
println!("{:?}", v1); // 正常使用

为什么在切片上调用 .into_iter() 不合适？
into_iter() 通常用于消耗（move）集合，而切片是不可变的引用（&[T]），无法被消耗。
在切片上调用 into_iter() 会让人误以为它会消耗切片，但实际上它只是返回一个迭代器，产生切片的引用（&T）。
使用 iter() 更明确地表示你只是想迭代切片的元素，而不涉及所有权转移。
into_iter() 更适合用于拥有所有权的集合（如 Vec<T>），而不是引用类型（如 &[T]）。

Iterator 用于迭代。
IntoIterator 用于将类型转换为迭代器。

std::vec::IntoIter 结构体

into_iter.filter
iter.map

实现Iterator trait的next方法，就可以使用Iterator的所有迭代器方法。

大多数Rust开发者都更倾向于使用迭代器风格。

迭代器是Rust语言中的一种零开销抽象（zero-cost abstraction），意味着在使用这些抽象时不会引
入额外的运行时开销。

循环和迭代器的性能：一样。

// 代码注释
/// 文档注释
//！ 条目注释

用pub use来重新导出部分条目，从而建立一套和你的内部结构不同的对外结构。

pub use来导出合适的公共API

当存在较多嵌套模块时，使用pub use将类型重新导出到顶层模块可以显著地改善用户体验。

智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但拥有额外的元数据和附加功能。

引用和智能指针之间还有另外一个差别：引用是只借用数据的指针；而与之相反地，大多数智能指针本身就拥有 它们指向的数据。

String和Vec<T> 都是智能指针。

通常会使用结构体来实现智能指针，但区别于一般结构体的地方在于它们会实现Deref与Drop这两个trait。

智能指针作为一种设计模式被相当频繁地应用到了Rust。

Box<T>，可用于在堆上分配值。
Rc<T>，允许多重所有权的引用计数类型。
Ref<T>和RefMut<T>，可以通过RefCell<T>访问，是一种可以在运行时而不是编译时执行借用规则的类型。

使用装箱定义递归类型：使用Box<T>将递归类型的大小固定下来

Box三种场景：
1。当你拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文环境中使用这个类型的值时。
2。当你需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时。
3。当你希望拥有一个实现了指定trait的类型值，但又不关心具体的类型时。 trait对象场景

Box<T>属于智能指针的一种，因为它实现了Deref trait，并允许将Box<T>的值当作引用来对待。当一个Box<T>值离开作用域时，因为它实现了Drop trait，所以Box<T>指向的堆数据会自动地被清理释放掉。

通过Deref trait将智能指针视作常规引用

* 解引用。
& 引用。

解引用需要实现Deref trait。

当某个类型T实现了Deref trait时，它能够将T的引用转换为T经过Deref操作后生成的引用。

DerefMut trait

解引用转换（deref coercion）是Rust为函数和方法的参数提供的一种便捷特性。

借助Drop trait在清理时运行代码

Rust并不允许我们手动调用Droptrait的drop方法；但是，你可以调用标准库中的std::mem::drop函数来提前清理某个值。

Rust中的drop函数正是这样一个析构函数。

Rc<T>的类型来支持多重所有权，它名称中的Rc是Reference counting（引用计数）的缩写

Rc<T>只能被用于单线程场景中

使用Rc<T>共享数据

Rc::clone只会增加引用计数。

Rc<T>通过不可变引用使你可以在程序的不同部分之间共享只读数据。

内部可变性模式及RefCell<T>类型，该类型可以与Rc<T>联合使用来绕开不可变的限制。

内部可变性 （interior mutability）是Rust的设计模式之一：它允许你在
只持有不可变引用的前提下对数据进行修改

Rust的设计模式：内部可变性，RAII，类型状态模式，Newtype 模式，Builder 模式，

Rust 的设计模式充分利用了其类型系统和所有权模型，强调安全性、性能和灵活性。

使用RefCell<T>在运行时检查借用规则，RefCell<T>类型代表了其持有数据的唯一所有权

内部可变性：可变地借用一个不可变的值

内部可变性的应用场景：模拟对象

使用RefCell<T>在运行时记录借用信息

RefCell<T>会基于这一技术来维护和编译器同样的借用检查规则：在任何一个给定的时间里，它只允许你拥有多个不可变借用或一个可变借用。

将Rc<T>和RefCell<T>结合使用来实现一个拥有多重所有权的可变数据

Rc<RefCell<i32>>

Rc<T>允许多个所有者持有同一数据，但只能提供针对数据的不可变访问。如果我们在
Rc<T>内存储了RefCell<T>，那么就可以定义出拥有多个所有者且能够进行修改的值了。

Mutex<T>，它被用于实现跨线程情形下的内部可变性模式。

borrow方法和borrow_mut方法会分别返回Ref<T>与RefMut<T>这两种智能指针

使用Weak<T>代替Rc<T>来避免循环引用

循环引用会造成内存泄漏

在编译期彻底防止内存泄漏并不是Rust作出的保证之一，这也意味着内存泄漏在Rust中是一种内存安全行
为。

Rust团队曾经认为保证内存安全和防止并发问题是两个截然不同的挑战，需要使用不同的方法来解决它们。但是随着时间的推移，发现所有权和类型系统这套工具集能够同时帮助管理内存安全及并发问题！借助所有权和类型检查，许多并发问题可以在Rust中暴露为编译时错误而不是运行时错误。

Sync trait与Send trait，能够将Rust的并发保证从标准库中提供的类型扩展至用户自定义类型。

Rust标准库只提供了1:1线程模型的实现。

Rust会尽可能地保持几乎没有运行时的状态，这使我们可以方便地与C语言进行交互并获得较高的性能。

使用spawn创建新线程
使用JoinHandle等待所有线程结束
在线程中使用move闭包

move闭包常常被用来与thread::spawn函数配合使用，它允许你在某个线程中使用来自另一个线程的数据。

通过将v的所有权转移给新线程，我们就可以向Rust保证主线程不会再次使用v。

Go：不要通过共享内存来通信，而是通过通信来共享内存。

mpsc是英文“multiple producer, single consumer

send函数会获取参数的所有权，并在参数传递时将所有权转移给接收者。

任何编程语言中的通道都有些类似于单一所有权的概念，因为你不应该在值传递给通道后再次使用它。
而基于共享内存的并发通信机制则更类似于多重所有权概念：多个线程可以同时访问相同的内存地址。

互斥体一次只允许一个线程访问数据：
必须在使用数据前尝试获取锁。
必须在使用完互斥体守护的数据后释放锁，这样其他线程才能继续完成获取锁的操作。

Mutex<T>是一种智能指针。更准确地说，对lock的调用会返回一个名为MutexGuard的智能指针。
这个智能指针通过实现Deref来指向存储在内部的数据，它还会通过实现Drop来完成自己离开作用域时的自动解锁操作

不会因为忘记释放锁而导致其他线程无法继续使用该互斥体。锁的释放过程是自动发生的。

Arc<T>包裹Mutex<T>来实现多线程共享所有权。【原子引用计数Arc<T>】 
Arc::new(Mutex::new(0));
Rc::new(Mutex::new(0)) 不行，rc不是线程安全的。

Arc<T>与Rc<T>的接口完全一致。

学习：std::sync 和 std::future

Mutex<T>与Cell系列类型有着相似的功能，它同样提供了内部可变性。

RefCell<T>/Rc<T>和Mutex<T>/Arc<T>之间的相似性

两个Rc<T>值在互相指向对方时会造成内存泄漏。与之类似， 使用Mutex<T> 也会有产生死锁（deadlock）的风险。

使用Sync trait和Send trait对并发进行扩展

Rust语言本身内置的并发特性非常少，本章讨论的几乎每一个并发特性都是标准库的一部分，而非语言本身内置的。

两个并发概念被内嵌在了Rust语言中，是std::marker模块内的Sync trait与Send trait。

允许线程间转移所有权的Send trait：几乎所有的Rust类型都实现了Send，除了Rc<T>等极少数的类型。

允许多线程同时访问的Sync trait：只有实现了Sync trait的类型才可以安全地被多个线程引用。智能指针Rc<T>同样不满足Sync约束，其原因与它不满足Send约束类似。

对于任何类型T，如果&T满足约束Send，那么T就是满足Sync的

标签trait，Send与Sync甚至没有任何可供实现的方法。它们仅仅被用来强化与并发相关的不可变性。

手动实现Send和Sync是不安全的

与Send类似，所有原生类型都满足Sync约束，而完全由满足Sync的类型组成的复合类型也都会被自动识别为满足Sync的类型。

Rust在标准库中提供了用于实现消息传递的通道，也提供了可以在并发场景中安全使用的智能指针：Mutex<T>与Arc<T>

结构体和枚举：封装。
trait：继承。

面向对象：对象、封装及继承

对象包含数据和行为：Rust是面向对象的：结构体和枚举包含数据，而impl块则提供了可用于结构体和枚举的方法。
封装实现细节：pub关键字可以实现对细节的封装。
继承：作为类型系统和代码共享机制的继承。Rust选择了trait对象来代替继承
多态：trait对象。

使用trait对象来存储不同类型的值，为共有行为定义一个trait

Rust中的默认trait方法来进行代码共享。

选用一种指针，例如&引用或Box<T>智能指针等，并添加dyn关键字与指定相关trait来创建trait对象。

Rust中使用泛型来构建不同类型的抽象，并使用trait约束来决定类型必须提供的具体特性。这一技术有时也被称作限定参数化多态（bounded parametric polymorphism）。

带有trait约束的泛型参数一次只能被替代为一个具体的类型，而trait对象则允许你在运行时填入多种不同的具体类
型。

Rust实现多态性的两种主要方式：范型和trait约束（编译时），trait对象（运行时）

泛型 vs Trait 对象
特性			泛型（Generics）				Trait 对象（Trait Objects）
分派方式		静态分派（编译时确定）			动态分派（运行时确定）
性能			高性能，无运行时开销			较低性能，有运行时开销
类型擦除		保留具体类型信息				擦除具体类型信息
适用场景		编译时类型已知，需要高性能		运行时类型动态选择，需要灵活性
代码生成		单态化，为每个类型生成单独代码	使用虚表，共享同一份代码
类型安全		编译时检查，类型安全			运行时检查，类型安全
集合存储		只能存储单一类型				可以存储多种类型（如 Vec<Box<dyn Trait>>）


使用trait对象来存储实现了相同trait的不同类型值

trait对象必须保证对象安全

trait就是对象安全的：
• 方法的返回类型不是Self。
• 方法中不包含任何泛型参数。

标准库中的Clone trait就是一个不符合对象安全的例子。
pub trait Clone {
  fn clone(&self) -> Self;
}

不能把将Clone trait用作trait对象。

Rust类型系统包括：静态类型，强类型，类型推断，泛型，Trait，Trait 对象，所有权和生命周期，
代数数据类型（结构体和枚举），模式匹配，类型别名（type Kilometers = i32），Newtype 模式（struct Meters(f64)），

Rust 中用于定义新类型的两种方式：类型别名和Newtype 模式

类型别名：用于简化代码，提高可读性，但不提供额外的类型安全性。
Newtype 模式：用于增强类型安全性，添加语义或行为，适合需要封装和扩展的场景。

保证了内存安全和并发安全，还提供了零成本抽象和高性能。

所有权系统确保内存安全，避免数据竞争和悬垂指针。
生命周期（lifetimes）用于管理引用的有效性。

宏：声明宏，过程宏（#[derive]派生宏，属性宏，函数宏）

std::default Default

借用规则：
不可变引用：可以同时存在多个不可变引用。
可变引用：同一时间只能存在一个可变引用，且不能与不可变引用共存。



pub struct CurrencyId(pub u32);

// u32转
impl From<u32> for CurrencyId {
    fn from(value: u32) -> Self {
        CurrencyId(value)
    }
}

impl FromStr for CurrencyId {
    type Err = &'static str;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(CurrencyId(
            s.parse::<u32>().map_err(|_| "invalid CurrencyId")?,
        ))
    }
}

struct CurrencyId(u32)是元组结构体。元组结构体是一种没有字段名称的结构体，只能通过索引访问字段。
.0 是一种访问 元组结构体（tuple struct） 字段的语法。

// impl From<u32> for CurrencyId
// From<u32>：用于将 u32 转换为 CurrencyId。
// Into<CurrencyId>：自动实现，用于将 u32 转换为 CurrencyId。
let currency_id:CurrencyId = CurrencyId::from(123);
let currency_id2:CurrencyId = 123.into();
let currency_id3 = CurrencyId::from_str("123").unwrap();
let currency_id4:CurrencyId = "123".parse().unwrap();

FromStr调用两种方式：1. ::from_str("123") 2. "123".parse()
